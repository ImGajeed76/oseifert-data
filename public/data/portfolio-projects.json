[
  {
    "id": "908987290",
    "title": "Syrup",
    "description": "Syrup is a lightweight, open-source browser extension designed to make finding and applying the best coupons effortless, prioritizing transparency, user privacy, and ethical design over the profit-driven motives seen in many alternatives.",
    "mainContent": "# Syrup: Building an Open-Source, Ethical Alternative to Honey\n\n## The Idea: What It Is and Why I Built It\n\nSyrup is a browser extension that automatically finds and applies coupons while you shop online. The core idea was sparked by discussions around the popular extension Honey, particularly Hexium's YouTube video \"Honey is a SCAM... so I made my own\" and the original \"Exposing the Honey Influencer Scam\" video. These highlighted concerns about data privacy, transparency, and the business models of existing coupon tools. Funny enough, I'd been thinking about a similar concept myself just days before seeing Hexium's video.\n\nThe main problem Syrup addresses is the lack of a truly open-source, community-driven, and privacy-respecting coupon finder. Existing tools often feel like black boxes, potentially collecting more data than necessary or prioritizing certain retailers for profit. My motivation was to contribute to building a better alternative – one that puts users first. Hexium's initial version was a proof-of-concept, and seeing the need for a robust backend, I offered to build it. While others initially showed interest, my motivation kept me going, and I dove into creating the API. This project is for anyone who wants an effective coupon tool they can trust and potentially even contribute to.\n\n## The Journey: From Concept to Reality\n\nMy first step was focusing on the backend API, aiming for something reliable and efficient. I decided on the following tech stack:\n*   **Go (Golang):** I chose Go because I wanted something fast and efficient. Its ability to compile into a single binary makes deployment incredibly simple, which is great for an open-source project. Plus, I was eager to learn it, and it turned out to be a fantastic language for building web APIs – surprisingly straightforward.\n*   **PostgreSQL:** A powerful and reliable open-source relational database, perfect for storing structured data about coupons, stores, and user feedback (like ratings).\n*   **Redis:** Selected specifically to tackle performance issues. Caching frequently accessed data or computed results (like coupon scores) in Redis significantly speeds up responses.\n\nWith these tools, I built the [DiscountDB-API](https://github.com/ImGajeed76/discountdb-api), an open-source backend to manage coupon data. I also created a simple frontend, [DiscountDB](https://discountdb.ch/), to interact with it. Seeing my commitment and the functional backend, Hexium added me as a maintainer for the main Syrup browser extension project, which now uses the DiscountDB-API.\n\nThe project continues to evolve. We are currently planning and discussing a [new V2 API standard](https://github.com/Abdallah-Alwarawreh/Syrup/pull/120). The goal here is decentralization and flexibility. We want users to be able to host their own backend instances or even develop entirely new backends conforming to the standard, simply by changing the API URL in the extension settings. This supports the vision of a truly public, free, and anonymous coupon database ecosystem.\n\n## Navigating Challenges: Hurdles and Solutions\n\nThe biggest initial hurdle was **performance**. Calculating the best coupon involved potentially complex scoring and filtering logic across many coupons. Early versions of the API could take up to 4 seconds for some requests, which is far too slow for a good user experience.\n*   **Solution:** Implementing Redis caching was key. By storing recent search results and pre-calculated scores, we drastically reduced response times, often down to around 200ms.\n*   **Future Exploration:** I've also looked into technologies like SpacetimeDB. While primarily designed for real-time multiplayer games, its architecture might offer interesting possibilities for efficiently handling computations like coupon scoring in the future. It's an idea I'm keeping in mind.\n\nAnother significant challenge is **coupon management**. Currently, adding new coupons and managing existing ones effectively within the database is difficult.\n*   **Solution:** This is a core focus of the upcoming V2 API design. We're building the new standard with robust coupon submission, verification, and management features in mind.\n\nOn a personal level, tackling this project meant **learning Go from scratch**. While a challenge initially, it was incredibly rewarding. I quickly grew to appreciate the language's simplicity, performance, and tooling, which made building the API an enjoyable process.\n\n## The Outcome: Where It Stands and What I Learned\n\nSyrup and its backend (DiscountDB-API) are functional and actively used, but development is ongoing. As an open-source project maintained by volunteers (like me, Hexium, and others) in our free time, progress can sometimes be slow, but it's steady.\n\nWe haven't fully realized the V2 vision yet, but the current version successfully provides an ethical, open-source alternative, achieving the core initial goal.\n\nKey Learnings:\n*   **Technical Skills:** Gained significant experience in Go, API design (RESTful principles), database management (PostgreSQL), and performance optimization using caching (Redis).\n*   **Open Source:** Learned about collaborating on a public project, managing contributions (even if small-scale currently), and the importance of clear standards (like the V2 API plan).\n*   **Problem Solving:** Tackling the performance issues required research and understanding trade-offs between different caching strategies.\n\nI'm most proud of successfully learning Go through this project and becoming a maintainer alongside Hexium, contributing meaningfully to a project I believe in.\n\nPotential next steps include finalizing and implementing the V2 API standard, building better tools for coupon management, and continuing to grow the Syrup user and contributor community.\n\n\n## Links:\n*   Syrup Website: [https://joinsyrup.com/](https://joinsyrup.com/)\n*   Syrup Extension Repository: [https://github.com/Abdallah-Alwarawreh/Syrup](https://github.com/Abdallah-Alwarawreh/Syrup)\n*   DiscountDB API Repository: [https://github.com/ImGajeed76/discountdb-api](https://github.com/ImGajeed76/discountdb-api)\n*   DiscountDB Frontend/Demo: [https://discountdb.ch/](https://discountdb.ch/)\n*   Community Discord (Questions/Development): [https://discord.com/invite/SxTjmsS2g9](https://discord.com/invite/SxTjmsS2g9)\n*   Inspiration Video (Hexium): [\"Honey is a SCAM... so I made my own\"](https://www.youtube.com/watch?v=uBy9rERgmlU)\n*   Inspiration Video (Original): [\"Exposing the Honey Influencer Scam\"](https://www.youtube.com/watch?v=vc4yL3YTwWk)",
    "repoUrl": "https://github.com/Abdallah-Alwarawreh/Syrup",
    "createdAt": "2024-12-27T13:16:51Z",
    "updatedAt": "2025-10-20T12:57:42Z",
    "languages": [
      {
        "name": "TypeScript",
        "bytes": 222337,
        "percentage": 80.06546774507191,
        "color": "#3178c6"
      },
      {
        "name": "JavaScript",
        "bytes": 41131,
        "percentage": 14.811627186759527,
        "color": "#f1e05a"
      },
      {
        "name": "CSS",
        "bytes": 7201,
        "percentage": 2.593142091654843,
        "color": "#563d7c"
      },
      {
        "name": "Swift",
        "bytes": 5242,
        "percentage": 1.8876893271010535,
        "color": "#333"
      },
      {
        "name": "HTML",
        "bytes": 1783,
        "percentage": 0.6420736494126629,
        "color": "#e34c26"
      }
    ],
    "primaryLanguage": {
      "name": "TypeScript",
      "bytes": 222337,
      "percentage": 80.06546774507191,
      "color": "#3178c6"
    },
    "stars": 769,
    "forks": 41
  },
  {
    "id": "958635486",
    "title": "BFScript",
    "description": "BFScript is a compiler written in Python that translates a familiar, C-inspired syntax into notoriously minimalistic Brainfuck code. It aims to make developing complex Brainfuck programs more feasible by providing higher-level abstractions.",
    "mainContent": "# BFScript: Bridging the Gap Between Readability and Brainfuck\n\n## The Idea: What It Is and Why I Built It\n\nEver since I first encountered esoteric programming languages, Brainfuck stood out. Its extreme minimalism was fascinating, but also intimidating. It's Turing complete, meaning *theoretically* you can compute anything with it, but *practically*, writing or reading anything beyond simple examples is incredibly difficult. The idea of simplifying this process got stuck in my head.\n\nThis led me to create BFScript: a compiler that takes code written in a simpler, C-like syntax and translates it into functional Brainfuck code.\n\nMy initial attempt was a different project, the [Brainfuck Transpiler](https://github.com/ImGajeed76/brainfuck_transpiler). However, I soon realized that approach had fundamental limitations and wasn't truly Turing complete. It couldn't handle the complexity I envisioned. So, I decided to start over with a more robust compiler approach, which became BFScript.\n\nPrimarily, this is a passion project exploring compiler design in a severely constrained environment—how do you build a usable language when your target has no stack, no registers, and only 8 instructions? It's for me, for the fun of tackling a weird challenge, and maybe for anyone else intrigued by the intersection of conventional programming and esoteric languages.\n\n**What is Brainfuck, Anyway?**\n\nBefore diving into BFScript, it helps to understand the target language. Brainfuck uses only eight simple commands to manipulate a tape of memory cells:\n\n| Command | Description                        |\n|:--------|:-----------------------------------|\n| `>`     | Increment the data pointer.        |\n| `<`     | Decrement the data pointer.        |\n| `+`     | Increment the byte at the pointer. |\n| `-`     | Decrement the byte at the pointer. |\n| `.`     | Output the byte at the pointer.    |\n| `,`     | Input a byte to the pointer.       |\n| `[`     | Jump forward if byte is zero.      |\n| `]`     | Jump backward if byte is non-zero. |\n\nA simple \"Hello World!\" in Brainfuck looks like this:\n\n```bf\n++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.\n```\n\nAs you can see, readability isn't its strong suit. BFScript aims to fix that!\n\n## The Journey: From Concept to Reality\n\nAfter hitting the limits with the simple transpiler, I knew I needed a more structured approach for BFScript. I decided to build a proper compiler using Python.\n\nThe key technology choices were:\n\n1.  **Python:** I chose Python because I'm comfortable with it, and it has excellent string manipulation capabilities and libraries, which are crucial for code generation. Its readability also helps manage the compiler's complexity.\n2.  **Lark (Parsing Library):** Instead of writing a parser from scratch, I used Lark. It allows defining the grammar of the BFScript language in a clean way and automatically generates a parser that turns BFScript code into a structured tree (Abstract Syntax Tree - AST). This saved a massive amount of effort and let me focus on the harder part: translation.\n\nThe compilation process generally involves:\n\n1.  **Parsing:** Lark reads the BFScript code (`.bfs` file) and validates its syntax, creating an AST.\n2.  **Code Generation:** My Python code walks through this AST. For each node (like a variable declaration, `while` loop, `output` call), it generates the corresponding sequence of Brainfuck commands. This involves figuring out how to manage Brainfuck's memory tape to represent variables and control flow.\n\nThe BFScript language itself evolved to include features essential for non-trivial programs:\n\n*   Variables (`size_t name = value;`)\n*   Arithmetic (`+`, `-`)\n*   Loops (`while (condition) { ... }`)\n*   Basic I/O (`output('A');`, `output(variable);`)\n\nHere's an example of BFScript code that prints a pyramid, showcasing its readability compared to raw Brainfuck:\n\n```c\n// --- Pyramid Printer ---\n// Prints a pyramid of '*' characters using nested loops.\n\nsize_t height = 7; // Declare and initialize a variable\n\nsize_t current_row = 1;\nsize_t chars_for_this_row = 1;\n\n// Loop for each row\nwhile (current_row <= height) {\n\n    // --- Print leading spaces ---\n    size_t spaces_needed = height - current_row;\n    size_t spaces_printed = 0;\n    while (spaces_printed < spaces_needed) {\n        output(' '); // Output a character literal\n        spaces_printed = spaces_printed + 1;\n    }\n\n    // --- Print the characters ('*') ---\n    size_t chars_printed = 0;\n    while (chars_printed < chars_for_this_row) {\n        output('*');\n        chars_printed = chars_printed + 1;\n    }\n\n    // --- Print a newline character ---\n    output('\\n');\n\n    // --- Prepare for the next row ---\n    current_row = current_row + 1;\n    // Add 2 characters for the next row (1 -> 3 -> 5 -> ...)\n    chars_for_this_row = chars_for_this_row + 2;\n}\n```\n\nThis is much easier to understand and maintain!\n\n## How It Actually Works: The Technical Bits\n\nOkay, so the interesting part isn't just *that* it compiles to Brainfuck—it's *how*. I had to solve some genuinely tricky problems to make this work, and honestly, I'm pretty proud of the solutions I came up with.\n\n### The Code Generation Pattern: Functions All The Way Down\n\nHere's the thing I figured out early on: I couldn't just immediately spit out Brainfuck strings as I walked the AST. Why? Because when you're parsing something like `a + b`, you don't yet know *where* the result needs to go. Maybe it's going into a variable. Maybe it's being output directly. Maybe it's part of a bigger expression like `(a + b) * c`.\n\nSo instead, I built a system where every expression returns a Python function—a `code_func`—that generates the actual Brainfuck code when you call it:\n\n```python\ndef code_func(result_cell):\n    c = []\n    # Generate BF instructions that put the result in result_cell\n    return c\n```\n\nThis `result_cell` parameter is the key. It lets me decide *later* where the result should end up. When I finally know the context (like \"store this in variable X\"), I call the function and pass in the destination cell.\n\nFor something like `a + b * c`, these functions nest naturally:\n1. Parse `b * c` → get back a `code_func_mult`\n2. Parse `a + ...` → create a new `code_func_add` that *calls* `code_func_mult` internally\n3. When I finally execute this chain, it recursively generates the right BF code in the right order\n\nI later found out this is similar to something called \"tagless final\" from programming language research, which was kind of validating—I'd reinvented a real technique without knowing it existed.\n\n### Memory Management: Keeping Track of the Tape\n\nBrainfuck's tape is your only storage. No stack, no heap, just cells stretching out in both directions. I needed a way to manage this sanely.\n\nVariables get permanent locations—each `size_t` gets assigned a specific cell number and stays there. But temporary calculations (like the intermediate result of `b * c` in `a + b * c`) need *temporary* cells that get cleaned up after use.\n\nI built a `MemoryManager` class with a pool of temp cells (0–19 by default):\n\n```python\nclass MemoryManager:\n    def get_temp_cell(self):\n        if not self.temp_cell_pool:\n            raise MemoryError(\"Out of temporary cells!\")\n        return self.temp_cell_pool.pop(0)\n    \n    def release_temp_cell(self, cell):\n        self.temp_cell_pool.insert(0, cell)  # LIFO reuse\n```\n\nThe LIFO (last-in-first-out) reuse pattern is intentional—recently freed cells get reused first, which keeps the data pointer from wandering all over the tape. It's basically register allocation for a tape machine.\n\nIf you run out of temp cells, the compiler throws an error instead of silently corrupting memory. Better to fail loudly than generate broken code.\n\n### Control Flow: Making Loops and Ifs Work\n\nThis was the hardest part. Brainfuck only has `[...]` (loop while cell ≠ 0). No `if`/`else`, no `break`, no labels you can jump to. And every operation can move the data pointer, so if you're not careful, you'll end up in the wrong place and everything breaks.\n\nMy solution was to build abstractions that enforce pointer discipline. For example, here's `loop_managed`:\n\n```python\ndef loop_managed(self, condition_cell, loop_func):\n    code = self.move_to_cell(condition_cell)\n    code += self.open_brace()  # [\n    code += loop_func()  # Execute the loop body (might move pointer)\n    code += self.move_to_cell(condition_cell)  # Force pointer back\n    code += self.close_brace()  # ]\n    return code\n```\n\nThe key insight: after the loop body runs, *explicitly* move the pointer back to the condition cell. This prevents pointer drift bugs where the loop breaks because you're checking the wrong cell.\n\nFor `if/else`, it's trickier. I copy the condition to a temp cell, then use `[...]` to run the if-branch. For the else-branch, I set a flag beforehand and clear it if the if-branch runs—then I use another `[...]` to check if the flag is still set. It's hacky but it works.\n\n### Comparisons: The Countdown Algorithm\n\nYou can't just check if `a > b` in Brainfuck. No comparison instructions exist. So I had to get creative.\n\nMy solution for `greater_than`:\n1. Copy `a` and `b` to temporary cells (let's call them `temp1` and `temp2`)\n2. Loop: decrement both `temp1` and `temp2` by 1 each iteration\n3. If `temp2` hits zero first, then `a > b` (set result to 1)\n4. If `temp1` hits zero first or they hit zero together, then `a ≤ b` (result stays 0)\n\nIt's essentially simulating a comparison by counting down both numbers in parallel and seeing which runs out first. Not the most efficient algorithm, but it works and it's provably correct.\n\nSimilar logic applies to `<`, `==`, etc. Each comparison has its own little algorithm.\n\n### Why This Matters\n\nI didn't find tutorials for any of this. The problem space—compiling a C-like language to Brainfuck with complex expressions and control flow—basically doesn't exist elsewhere. These patterns emerged from trial and error, trying to keep the compiler maintainable as I added features.\n\nThe closure-based approach especially felt like a breakthrough moment. It made composition natural, prevented a ton of bugs, and kept the code surprisingly clean considering what it's doing.\n\n## Navigating Challenges: Hurdles and Solutions\n\nThis project was definitely challenging, pushing me to learn quite a bit.\n\n*   **Technical Challenges:**\n    *   **Brainfuck Logic:** The biggest hurdle was figuring out *how* to translate higher-level concepts into Brainfuck. How do you represent variables on the tape? How do you implement `while` loops or arithmetic efficiently using only `+`, `-`, `<`, `>`, `[`, `]`? This required studying Brainfuck programming techniques and designing specific Brainfuck \"subroutines\" for common operations. Managing the data pointer (`<`, `>`) effectively to avoid unnecessary movement was also tricky.\n    *   **Compiler Complexity:** Designing the compiler structure itself, ensuring the generated Brainfuck code was correct for all language features and their combinations, was complex. Debugging the *output* Brainfuck code was particularly difficult, as Brainfuck gives you very little feedback when something goes wrong.\n    *   **AI Wasn't Much Help:** I tried using AI assistants early on, but this problem is niche enough that they couldn't really guide me. There's no big corpus of \"C-to-Brainfuck compiler\" code for them to learn from. This forced me to think through the logic myself, which honestly made the learning experience better.\n*   **Non-Technical Challenges:** Mostly time management and staying motivated on a project that's complex and doesn't have an immediate practical application outside of the learning experience itself.\n\n*   **Solutions:**\n    *   I tackled the Brainfuck logic by breaking problems down. I'd figure out how to implement a small piece (like adding two numbers stored at specific tape locations) and then build upon that.\n    *   Using the Lark library significantly simplified the parsing stage, letting me focus on the translation logic.\n    *   Lots of trial-and-error, testing small BFScript snippets, and examining the generated Brainfuck code helped iron out bugs.\n\n## The Outcome: Where It Stands and What I Learned\n\nBFScript is currently functional and usable. You can write programs like the pyramid example above and compile them into working Brainfuck code. While there's always room for improvement and more features (some edge cases in conditionals are still buggy, and I'm not going back to debug that nightmare), I'm happy with its current state as a proof-of-concept and a learning tool.\n\n*   **Goals Achieved:** Yes, the main goal of creating a compiler that translates a C-like syntax into Turing-complete Brainfuck, overcoming the limitations of my previous transpiler, was met.\n*   **Key Learnings:**\n    *   A *lot* about compiler fundamentals (parsing, ASTs, code generation).\n    *   Deep appreciation for the challenges of working in highly constrained environments like Brainfuck.\n    *   How to map high-level programming constructs to low-level operations.\n    *   The value of using good tools and libraries (like Lark).\n    *   Problem-solving and debugging techniques for unconventional code.\n    *   That I could design compiler patterns independently that turn out to mirror real academic research.\n*   **Proudest Aspect:** Honestly, the closure-based code generation system. It emerged organically as I tried to handle nested expressions, and realizing later that it's similar to patterns from academic PL research (tagless final) was really validating. That \"independent discovery\" moment felt great.\n*   **Future Ideas:** While not actively planned, I've considered exploring optimizations for the generated Brainfuck code (making it shorter or faster—there's definitely redundant `+-<>` sequences I could collapse). The idea of using LLVM Intermediate Representation (IR) as a source, allowing potentially *any* language that compiles to LLVM to be compiled to Brainfuck, is also an interesting, though very ambitious, future thought experiment.",
    "repoUrl": "https://github.com/ImGajeed76/bfscript",
    "createdAt": "2025-04-01T14:14:04Z",
    "updatedAt": "2025-10-16T21:55:46Z",
    "languages": [
      {
        "name": "Python",
        "bytes": 116520,
        "percentage": 100,
        "color": "#3572A5"
      }
    ],
    "primaryLanguage": {
      "name": "Python",
      "bytes": 116520,
      "percentage": 100,
      "color": "#3572A5"
    },
    "stars": 4,
    "forks": 0
  },
  {
    "id": "989817079",
    "title": "Bergpreis - Soundbox",
    "description": "The Bergpreis Soundbox is an embedded audio playback system I developed during my apprenticeship. It replaces a disruptive siren in an interactive game with dynamic, high-quality sound effects and music played from an SD card, controlled by an STM32 microcontroller.",
    "mainContent": "# Bergpreis Soundbox: Engineering a Better Game Experience\n\n## The Idea: What It Is and Why I Built It\n\nDuring my apprenticeship as an Electronic Technician at the Technische Fachschule Bern (TFBern), I had the opportunity to work on a fascinating project: the \"Bergpreis - Soundbox.\" This project was an enhancement for an existing interactive game called \"Bergpreis\" (Mountain Prize), which was used to engage audiences at fairs and events.\n\n**What was the \"Bergpreis\" game about?**\n\nThe game involved two participants on stationary bicycles. After a start signal, they had to pedal as hard as possible, making their virtual figures climb a mountain on a screen. The faster they pedaled, the quicker their figure ascended. The original system used a loud and, frankly, quite disruptive siren for acoustic feedback. While effective at grabbing attention, it wasn't ideal for all environments and could become annoying over extended periods, especially in quieter settings or during prolonged use at exhibitions.\n\nThis is where the Soundbox came in. The goal was to replace the siren with a more sophisticated and flexible audio solution. Instead of a single, blaring noise, the new system needed to:\n\n*   Play various sound effects or music tracks (WAV files).\n*   Store these audio files on a readily available medium (a MicroSD card).\n*   Allow for volume control to suit different environments.\n*   Integrate with the existing game controller with minimal modification, as much of the game was already developed.\n\nThe Soundbox project was my Individual Practical Work (IPA), a significant part of my apprenticeship, allowing me to apply and expand my skills in electronics and embedded systems.\n\n## The Journey: From Concept to Reality\n\nDeveloping the Soundbox involved designing custom hardware, writing embedded software, and integrating everything into a functional unit.\n\n**Hardware Design:**\n\nThe heart of the Soundbox is an **STM32G474CET6 microcontroller**. This powerful MCU was chosen for its processing capabilities, suitable for handling audio data and real-time operations.\n\nThe key hardware components and design aspects include:\n\n*   **Audio Storage:** A **MicroSD card slot** allows for easy storage and updating of WAV audio files. Communication with the SD card is handled via the **SPI** (Serial Peripheral Interface) protocol.\n*   **Audio Output:** The digital audio data from the MCU is converted to an analog signal by its internal **DAC** (Digital-to-Analog Converter). This signal is then fed to an external **Adafruit MAX9744 Class-D stereo audio amplifier**, capable of delivering up to 20W per channel. We used one channel for a clear, loud output. The amplifier's volume and mute functions are controlled via **I2C**.\n*   **Control Interface:** The Soundbox receives commands from the main \"Bergpreis\" game controller via a **UART** (Universal Asynchronous Receiver/Transmitter) interface. This was crucial as the existing game system had limited available connections. We cleverly used the power supply line to also carry these data signals, which were then separated on the Soundbox PCB.\n*   **Power Supply:** The system is powered by a 12V input, which is then regulated down to 3.3V for the microcontroller and other digital components using an on-board switching regulator.\n*   **Custom PCB:** I designed a custom Printed Circuit Board (PCB) to house the microcontroller, SD card slot, power regulation circuitry, and connectors for the amplifier and external signals.\n*   **Enclosure:** A custom 3D-printed enclosure was designed to protect the electronics, aiming for a degree of robustness and resistance to light moisture, suitable for event use. It also included mounts for signal LEDs.\n\n**Software Development:**\n\nThe firmware for the STM32 microcontroller was developed to be modular and responsive.\n\n*   **Real-Time Operating System (RTOS):** **FreeRTOS** was used to manage multiple tasks concurrently. This was essential for handling audio playback, command processing, and other background operations smoothly without interference.\n*   **File System:** The **FatFs** library was integrated to manage files on the MicroSD card, allowing the Soundbox to read the WAV audio files.\n*   **Audio Playback Engine:** This core software module is responsible for:\n    *   Parsing WAV file headers to understand audio format (e.g., sample rate).\n    *   Reading audio data from the SD card.\n    *   Managing audio buffers.\n    *   Continuously feeding data to the MCU's DAC using **DMA** (Direct Memory Access). DMA is critical here as it offloads the CPU from the repetitive task of sending data samples to the DAC, freeing it up for other tasks and ensuring smooth, uninterrupted audio.\n*   **Command Handling:** A UART-based command protocol was defined to allow the main game to control the Soundbox. For example, a specific byte value would instruct the Soundbox to play \"1.wav\" or set the volume to a certain level. The protocol was designed to be simple, using single-byte commands to minimize transmission time over the shared power/data line.\n    *   The command byte was structured with the first 3 bits defining the command (e.g., Play, Stop, Set Volume, Mute) and the remaining 5 bits for parameters (e.g., track number 1-31, volume level 0-31).\n*   **Audio File Preparation:** Audio files (e.g., MP3 or other WAV formats) needed to be converted to a specific format: 16-bit Mono PCM WAV. The open-source tool **FFmpeg** was recommended for this conversion process.\n*   **Development Environment:** The firmware was developed using **STM32CubeMX** and **CLion**.\n\nThe overall software architecture separated hardware control, service logic (managing playback states), and application logic (responding to commands).\n\n## Navigating Challenges: Hurdles and Solutions\n\nThis project presented several interesting challenges:\n\n*   **Technical Challenges:**\n    *   **Smooth Audio Playback:** Ensuring continuous, glitch-free audio playback was paramount. This required careful management of data buffers, precise timing for the DAC, and efficient use of DMA and FreeRTOS to prevent underruns or overruns. The STM32G474's 170 MHz clock speed was beneficial here.\n    *   **Limited Interface:** The constraint of using the existing power line for data communication required a robust separation and signal conditioning circuit and a simple, reliable UART protocol.\n    *   **SD Card Reliability:** Interfacing with SD cards can sometimes be tricky; ensuring stable communication via SPI and proper handling with FatFs was important.\n    *   **Enclosure Design:** Creating a compact yet robust enclosure that allowed for easy assembly and access while providing some protection was an iterative process. The initial design for mounting signal lights had a slight measurement error that needed a workaround.\n*   **Non-Technical Challenges:**\n    *   Like any project, managing time effectively and debugging complex embedded systems (where you can't just `print()` everything easily) were part of the learning curve.\n\n*   **Solutions:**\n    *   The use of **DMA** for both DAC output and SPI communication significantly reduced CPU load, which was key for smooth audio.\n    *   **FreeRTOS** helped structure the code and manage concurrent operations, preventing tasks from blocking each other.\n    *   **Modular firmware design** made it easier to develop, test, and debug individual components of the software.\n    *   Careful **PCB layout**, keeping analog and digital grounds separate where appropriate, and using bypass capacitors helped with noise.\n    *   For the signal light mounting, while not perfect, there was still enough space to securely mount them.\n\n## The Outcome: Where It Stands and What I Learned\n\nThe Bergpreis Soundbox project was successfully completed. The final unit could reliably receive commands and play the corresponding WAV audio files from the MicroSD card, with controllable volume. It effectively replaced the old siren system, meeting all the core requirements defined in the project brief.\n\n*   **Goals Achieved:** Yes, the primary goal of creating a flexible, SD card-based audio playback system to enhance the \"Bergpreis\" game was met.\n*   **Key Learnings:** This project was an immense learning experience. I gained practical skills and deeper understanding in:\n    *   **Microcontroller Programming:** Working extensively with the STM32 platform.\n    *   **Peripheral Interfacing:** Implementing SPI for SD cards, I2C for the audio amplifier, UART for command input, and using DACs and DMA.\n    *   **Real-Time Operating Systems:** Practical application of FreeRTOS for task scheduling and inter-task communication.\n    *   **Audio Fundamentals:** Understanding WAV file formats and digital audio playback.\n*   **Proudest Aspect:** Seeing (and hearing!) the whole system come together – from designing the PCB, soldering components, writing the firmware, to finally playing custom sounds on command – was incredibly rewarding. The successful integration of FreeRTOS and DMA for smooth audio playback felt like a significant achievement.\n\nThe Bergpreis Soundbox was a challenging yet highly fulfilling project that significantly contributed to my skills as an aspiring Electronic Technician.",
    "repoUrl": "https://github.com/ImGajeed76/SoundboxPortfolio",
    "createdAt": "2025-05-24T22:15:22Z",
    "updatedAt": "2025-09-25T16:27:50Z",
    "languages": [],
    "primaryLanguage": null,
    "stars": 1,
    "forks": 0
  },
  {
    "id": "1020935354",
    "title": "Axogen",
    "description": "Axogen is a TypeScript-native configuration system that unifies typed environment variables, code generation, and task management for any project in any language, prioritizing type safety and developer experience over the scattered .env file chaos.",
    "mainContent": "# Axogen: Building a TypeScript-Native Config System Because .env Files Drive Me Crazy\n\n## The Idea: What It Is and Why I Built It\n\nAxogen is a configuration management tool that lets you define everything once in TypeScript and generate multiple config formats automatically. You write your config in TypeScript with full type safety and Zod validation, and it spits out .env files, JSON configs, YAML files, Docker configs, Kubernetes manifests - whatever you need. The key difference from other tools: it validates everything before your app even starts, catching errors in milliseconds instead of waiting for your app to crash 30 seconds into startup.\n\nThe whole thing started because I hit my absolute breaking point while working on [AxonotesCore](https://github.com/axonotes/AxonotesCore). The project had grown into this nightmare of scattered configuration files - hardcoded URLs buried in package.json scripts, different ports scattered across multiple .env files, and the classic \"change one thing, forget to update it in three other places\" problem. \n\nThe moment I knew I had to build something was when I tried to show a new developer how to set up the project locally. I watched them get confused, frustrated, and ultimately give up because our configuration was so scattered and inconsistent. That's when I realized: configuration shouldn't be this hard, and definitely shouldn't be a barrier to onboarding new people.\n\n## The Journey: From Frustration to Solution\n\nMy first attempt was actually just trying to clean up AxonotesCore's existing setup manually. But I quickly realized the problem was fundamental - we had the same information (ports, URLs, database connections) repeated across different files in different formats, and there was no single source of truth.\n\nI chose **TypeScript** as the foundation because developers already know it, and I wanted real type safety. The key was integrating **Zod** for schema validation - not just string replacement, but actual validation that catches invalid URLs, malformed base64, wrong number formats before anything gets generated.\n\nThe tech stack evolved to:\n* **TypeScript + Zod:** For the config definition and validation\n* **Template engines:** Nunjucks, Handlebars, Mustache support for complex config generation  \n* **Universal file support:** 10+ formats for both reading and generating configs\n* **Command system:** Built-in task runner with nested commands and typed arguments\n\nHere's what a real config looks like:\n\n```typescript\nconst env = loadEnv(\n  z.object({\n    DATABASE_URL: z.url(),\n    API_PORT: z.coerce.number().default(3001),\n    WEB_PORT: z.coerce.number().default(3000),\n    NODE_ENV: z.enum([\"development\", \"staging\", \"production\"]).default(\"development\"),\n  })\n);\n\nexport default defineConfig({\n  targets: {\n    api: env({\n      path: \"api/.env\",\n      variables: {\n        DATABASE_URL: env.DATABASE_URL,\n        PORT: env.API_PORT,\n      },\n    }),\n    web: env({\n      path: \"web/.env.local\", \n      variables: {\n        NEXT_PUBLIC_API_URL: `http://localhost:${env.API_PORT}`,\n      },\n    }),\n  },\n});\n```\n\nChange `API_PORT` to 4000, run `axogen generate`, and every URL automatically updates. One source of truth, everything else follows.\n\nThe workflow I ended up with works really well across my two development machines. Pull code, update `.env.axogen` with my local secrets, run `axogen generate`, and everything just works. No hunting through files, no missing variables, no debugging why services can't connect. When you run `axogen run dev`, it validates your config first - if something's missing or wrong, you know immediately with a clear error message instead of waiting for your app to fail somewhere deep in the startup process.\n\n## Navigating Challenges: Hurdles and Solutions\n\nThe biggest challenge was **scope creep in the best way possible**. What started as a simple config generator kept growing because each problem I solved revealed another one.\n\n**Type Safety Evolution:** My initial API was pretty loose. I had to completely overhaul it to use dedicated functions for each target type (`env()`, `json()`, `yaml()`) so TypeScript actually knows what you're doing and provides proper IntelliSense.\n\n**Secret Detection:** I realized people could accidentally push production API keys if Axogen generated them into non-gitignored files. So I built automatic secret detection - if variables look like secrets (API keys, tokens, etc.) and the target file isn't gitignored, Axogen refuses to generate. You can override with `unsafe()` but you have to explicitly say WHY it's safe.\n\n**Command System Complexity:** Simple string commands weren't enough. I ended up building a full nested command system that supports everything from basic strings to complex command objects with help text, typed arguments, and custom logic:\n\n```typescript\ncommands: {\n  \"dev:api\": `cd api && npm run dev --port ${env.API_PORT}`,\n  deploy: cmd({\n    help: \"Deploy the application\",\n    options: {\n      environment: z.enum([\"staging\", \"production\"]).default(\"staging\"),\n    },\n    exec: async (ctx) => {\n      console.log(`🚀 Deploying to ${ctx.options.environment}...`);\n    },\n  }),\n}\n```\n\n**Performance was surprisingly not a problem** - I didn't implement any optimizations, but it generates 10,000 config files in about 2.2 seconds. Turns out when you're basically validating once and converting JSON to different formats, things are naturally pretty fast.\n\n## The Outcome: Where It Stands and What I Learned\n\nAxogen is currently at v0.5.7 with 20 GitHub stars. It's functional and I've fully migrated AxonotesCore to use it, but it's definitely still evolving. The core vision is achieved though - you can define configuration once in TypeScript and generate any format you need with full type safety.\n\nOne important aspect: there's zero lock-in. The generated files are standard formats (.env, JSON, YAML) that work without Axogen. Don't like it? Just delete it and keep using the files. No migration needed, no vendor lock-in, the files are yours.\n\n**Key things I learned:**\n* **Developer experience really matters** - The console themes, colored output, and proper error messages aren't just pretty, they make the tool genuinely enjoyable to use\n* **Type safety everywhere** - Using Zod for validation means no more silent failures. You get beautiful error messages that actually help you fix problems\n* **Start simple, grow complex** - You can begin with basic configs and gradually add more sophisticated features as needed\n* **Validation before execution** - Catching config errors in milliseconds before app startup is way more valuable than I initially thought\n\nI'm most proud of the command system and the secret detection. Both solve real problems I've encountered, and they do it in a way that feels natural to use.\n\n**What's next:** Project initialization commands, better secrets management integration, and runtime loading capabilities. The goal is becoming production-ready while keeping the developer experience that makes config management actually fun.\n\nThe project successfully bridges the gap between dotenv's simplicity and enterprise complexity. It's TypeScript-native but works for any project in any language - Python APIs, Go microservices, Docker configs, Kubernetes manifests, all from one source of truth.\n\n## Links:\n* GitHub Repository: [https://github.com/axonotes/axogen](https://github.com/axonotes/axogen)\n* Documentation: [https://axonotes.github.io/axogen/](https://axonotes.github.io/axogen/)\n* NPM Package: [https://www.npmjs.com/package/@axonotes/axogen](https://www.npmjs.com/package/@axonotes/axogen)\n* Discord: [https://discord.gg/myBMaaDeQu](https://discord.gg/myBMaaDeQu)",
    "repoUrl": "https://github.com/axonotes/axogen",
    "createdAt": "2025-07-16T16:07:18Z",
    "updatedAt": "2025-09-14T22:12:30Z",
    "languages": [
      {
        "name": "TypeScript",
        "bytes": 378782,
        "percentage": 82.68201056930623,
        "color": "#3178c6"
      },
      {
        "name": "CSS",
        "bytes": 43843,
        "percentage": 9.57022083781725,
        "color": "#563d7c"
      },
      {
        "name": "MDX",
        "bytes": 35440,
        "percentage": 7.735981262510395,
        "color": "#333"
      },
      {
        "name": "HTML",
        "bytes": 54,
        "percentage": 0.011787330366127578,
        "color": "#e34c26"
      }
    ],
    "primaryLanguage": {
      "name": "TypeScript",
      "bytes": 378782,
      "percentage": 82.68201056930623,
      "color": "#3178c6"
    },
    "stars": 20,
    "forks": 0
  },
  {
    "id": "933416005",
    "title": "Charmer",
    "description": "Charmer is a Go package designed to automatically generate Terminal User Interfaces (TUIs) directly from your Go functions. Leveraging the power of Charm libraries, it aims to transform annotated functions into interactive command-line interfaces, removing the need to manually build the UI.",
    "mainContent": "# Charmer: Turning Go Functions into Interactive TUIs\n\n## The Idea: What It Is and Why I Built It\n\nCharmer is a Go library that takes specially annotated Go functions and automatically builds a navigable Terminal User Interface (TUI) around them. The core idea is to drastically simplify the process of creating command-line tools that need more than just simple flags – tools where users can browse and execute different functionalities easily.\n\nThe motivation for Charmer grew directly out of my work on the [TFUtils-GO](https://oseifert.vercel.app/projects/933782301) project. While rewriting TFUtils in Go, I realized I needed a robust way to discover and present various commands (like project setup, file management, etc.) within a TUI. Instead of building this logic directly into TFUtils-GO, I saw an opportunity to create a separate, reusable library. I wanted something modular that could potentially be used for other Go applications needing a simple TUI structure, not just for my specific TFBern tool.\n\nCurrently, the primary user is TFUtils-GO (and therefore, myself and potentially fellow students). However, I envision Charmer being useful for any Go developer who wants to quickly expose functions through an interactive command-line interface without getting bogged down in TUI implementation details.\n\n## The Journey: From Concept to Reality\n\nThe core technical choice was to build upon the excellent [Charm](https://charm.sh/) ecosystem (libraries like Bubble Tea for TUI logic and Lipgloss for styling). These libraries provide the building blocks for creating beautiful and functional TUIs in Go. My goal with Charmer was to create a higher-level abstraction *on top* of Charm, specifically focused on the pattern of \"functions as commands.\"\n\nInstead of relying on runtime reflection, the design uses a **custom code generator**. Before building the final application, the developer runs this generator. It scans the project for specially marked functions (the \"Charms\"), gathers information about them (like their names and parameters), and then **generates Go code that explicitly imports and registers these functions** within the Charmer framework. This generated file is then compiled into the final binary. This approach avoids the potential overhead and complexities of reflection and ensures that all discoverable functions are known at compile time. A significant part of the early development focused on building this generator and defining how functions should be structured or annotated to be correctly picked up and integrated into the TUI.\n\nAs the idea developed, I realized that many command-line tools interact with files and configurations. This led to developing helper components within Charmer itself, aiming to make common tasks easier for the functions that Charmer would eventually expose.\n\n## Navigating Challenges: Hurdles and Solutions\n\nOne of the main challenges was designing abstractions that are both powerful and simple to use. I wanted to hide complexity without losing flexibility. A prime example arose when dealing with file operations needed by TFUtils-GO commands.\n\n*   **Challenge:** How to handle file operations consistently, whether the files are local or on a remote server (like SFTP), without forcing the developer using Charmer to write complex conditional logic?\n*   **Solution:** I developed my own path handling abstraction within Charmer, inspired by Python's `pathlib`. This allows treating different kinds of paths (local, SFTP) uniformly. You can create path objects for different sources and use simple methods like `CopyTo` to transfer files between them, abstracting away the underlying protocol differences.\n\n    Here’s a conceptual example of what this enables:\n    ```go\n    // NOTE: This is illustrative syntax and may change.\n    \n    // Define a path on an SFTP server\n    path1 := path.New(\"sftp://user@domain.com/remote/path/file.txt\")\n    // Define a local path\n    path2 := path.New(\"/local/destination/file.txt\")\n    \n    // Copy from SFTP to local with one command\n    err := path1.CopyTo(path2)\n    ```\n\n*   **Challenge:** If Charmer's helpers handle SFTP, how do we manage credentials securely without hardcoding them or constantly prompting the user?\n*   **Solution:** I created a small configuration management utility built around the [go-keyring](https://github.com/zalando/go-keyring) library. This allows storing sensitive information like passwords or API keys securely in the operating system's native keyring.\n\n    ```go\n    // NOTE: This is illustrative syntax and may change.\n    \n    // Create a config instance tied to a specific environment/app name\n    cfg := config.New(\"my-app-config\")\n    \n    // Set a secret value (stored securely in the keyring)\n    err := cfg.Set(\"sftp_password\", \"mySecretPassword\")\n    \n    // Retrieve the secret value later\n    password := cfg.Get(\"sftp_password\")\n    ```\n    This way, credentials are kept safe, managed by the OS, and easily accessible when needed by Charmer-powered functions.\n\n## The Outcome: Where It Stands and What I Learned\n\nCharmer is still in the early stages of development, but the core concept is taking shape, and it's already serving its initial purpose as the engine for TFUtils-GO. While the ultimate goal of a fully generic, easy-to-use TUI generator isn't complete, it feels achievable.\n\nThis project has been a great way to dive deeper into Go, particularly exploring generators, interface design, and building reusable libraries. Working with the Charm libraries has also been insightful. I've learned a lot about the importance of good abstraction and how challenging but rewarding it can be to design APIs that are simple on the surface but handle complexity underneath.\n\nI'm particularly pleased with the path handling abstraction. The ability to represent and operate on local and remote files using the same interface feels like a powerful simplification, making it much cleaner to write functions that interact with different file systems.\n\nFuture plans for Charmer include:\n*   Refining the function annotation and discovery process.\n*   Improving the generated UI/UX and developer experience (DX).\n*   Adding more tests to ensure it works reliably across different platforms.\n*   Expanding the built-in helpers based on common needs for CLI tools.\n*   Improving overall performance and robustness.",
    "repoUrl": "https://github.com/ImGajeed76/charmer",
    "createdAt": "2025-02-15T22:32:01Z",
    "updatedAt": "2025-04-22T08:09:43Z",
    "languages": [
      {
        "name": "Go",
        "bytes": 209343,
        "percentage": 100,
        "color": "#00ADD8"
      }
    ],
    "primaryLanguage": {
      "name": "Go",
      "bytes": 209343,
      "percentage": 100,
      "color": "#00ADD8"
    },
    "stars": 1,
    "forks": 0
  },
  {
    "id": "933782301",
    "title": "TFUtils-GO",
    "description": "TFUtils-Go is a powerful Go rewrite of the TFUtils project, designed to help TFBern students manage their projects more efficiently. This new version brings improved performance, easier distribution, and maintains the user-friendly approach of the original - now powered by Go!",
    "mainContent": "# TFUtils-GO: Making Development Less Annoying\n\n## The Idea: What It Is and Why I Built It\n\nTFUtils-GO is the next evolution of my earlier project, TFUtils. The original version, written in Python, served its purpose but ran into some significant challenges, as detailed in the [TFUtils article](https://oseifert.vercel.app/projects/851103459). The two main hurdles were:\n\n1.  **Difficult Distribution:** Sharing the Python tool with classmates required complex bundling into executables, which was often unreliable and platform-specific.\n2.  **Network Speed:** Accessing project templates over the TFBern network via standard file sharing felt sluggish in the Python version.\n\nWhile developing the original TFUtils, I started feeling constrained by its limitations and the growing complexity of managing the TUI and commands directly within the main application. This frustration pushed me to look for better solutions, which led me to discover and quickly grow fond of the Go programming language (Golang).\n\nGo seemed ideal for tackling the distribution and potential performance issues head-on. Furthermore, I considered our specific context at TFBern: as Electronics Technician apprentices, many of us gain experience with C programming. In my opinion, the syntax and concepts in Go feel closer to C than Python does, potentially making it **easier for fellow students to understand and contribute** to the project compared to Python. Go also enforces a **strict, unified code style** through tools like `gofmt`, which is a huge advantage for collaboration and long-term maintenance, ensuring the codebase remains consistent even with multiple contributors.\n\nA core goal driving this rewrite is **long-term maintainability**. I wanted to build a solid foundation that abstracts away the complexities of the TUI and command handling. This way, even after I leave TFBern, other students or teachers can hopefully **continue developing TFUtils-GO more easily** by focusing on creating specific command modules (\"Charms\") rather than wrestling with the core infrastructure.\n\nAs with the original, the primary audience for TFUtils-GO remains my fellow Electronics Technician apprentices at TFBern.\n\n## The Journey: From Concept to Reality\n\nBefore diving into coding this time, I spent more time thinking about the architecture. I realized that simply rewriting TFUtils line-for-line in Go wouldn't address the underlying desire for a more modular and potentially reusable system, nor would it fully achieve the goal of easier future contributions. I wanted something that could potentially be adapted for other command-line automation tasks beyond just the TFBern context.\n\nThis led to the creation of **[Charmer](https://github.com/ImGajeed76/charmer)**, a separate Go library born out of the needs for TFUtils-GO. Charmer is still in its early stages, but it provides the core framework for building TUI-based command-line tools like TFUtils-GO. Its main job is similar to the discovery mechanism in the old TFUtils: it automatically finds command modules (which I call \"Charms\") located in a specific `Charms` folder, loads them, and presents them in the text-based interface. This modular approach is key to simplifying future development.\n\nA significant amount of effort also went into optimizing file handling within Charmer. I developed a unified system for managing file paths, allowing it to treat SFTP paths (like `sftp://user@host/path/to/file`) and local paths (`C:\\path\\to\\file` or `/path/to/file`) consistently. This makes operations like copying files between a remote SFTP server and the local machine (or even between two SFTP servers) much simpler to implement within a Charm.\n\nConsequently, the TFUtils-GO project itself is much leaner this time. Instead of being packed with UI logic and command implementations, it primarily leverages the Charmer library for its core functionality. The specific TFBern-related tasks will be implemented as individual Charms, making the main project simpler and focusing contributions on self-contained modules.\n\n## The Outcome: Where It Stands and What I Learned\n\nTFUtils-GO is currently under active development and, while not yet matching the full feature set of the original Python version, the foundation is much stronger and designed for longevity. Development focus has understandably been on Charmer recently, as it provides the essential engine for TFUtils-GO and embodies the goal of creating an extensible core. However, the architecture is now in place, making it theoretically straightforward to reimplement all the previous TFUtils functions as Charms within this new Go-based structure.\n\nThis project has been a fantastic learning experience, significantly deepening my understanding of Go. While I'm still far from being an expert, I genuinely enjoy working with the language and its ecosystem, and I plan to continue using it for future projects. The focus on creating the reusable Charmer library has also taught me a lot about designing more abstract and maintainable software.\n\nI'm particularly proud of the unified path handling system developed for Charmer and the overall modular design facilitated by the library. Although much of the visible work resides within Charmer for now, it directly serves the primary goals set for TFUtils-GO: improved performance, easier distribution, and crucially, a more sustainable and collaborative future for the tool at TFBern.",
    "repoUrl": "https://github.com/ImGajeed76/tfutils-go",
    "createdAt": "2025-02-16T17:19:07Z",
    "updatedAt": "2025-04-22T06:44:41Z",
    "languages": [
      {
        "name": "Go",
        "bytes": 8443,
        "percentage": 100,
        "color": "#00ADD8"
      }
    ],
    "primaryLanguage": {
      "name": "Go",
      "bytes": 8443,
      "percentage": 100,
      "color": "#00ADD8"
    },
    "stars": 1,
    "forks": 1
  },
  {
    "id": "851103459",
    "title": "TF Utils",
    "description": "A user-friendly tool that helps TFBern students manage their projects more efficiently. Perfect for both beginners and advanced users, TF Utils streamlines project workflows with its intuitive interface and powerful features.",
    "mainContent": "# TF Utils: Making Project Setup Less Annoying\n\n## The Idea: What It Is and Why I Built It\n\nAt its core, TF Utils is a little command-line tool with a friendly text-based interface (TUI) that helps automate some of the tedious parts of setting up projects. Specifically, it's designed for fellow apprentices in the Electronics Technician (Elektroniker) program at TFBern.\n\nHonestly, the whole idea started because I was getting really frustrated myself. As an apprentice here, I also enjoy coding, and the constant cycle of copying project templates, carefully renaming everything, trying to keep track of versions, and dealing with inconsistencies across projects felt super inefficient. I thought, \"There has to be a better way,\" so I decided to build one. My goal was basically to scratch my own itch and hopefully make things a bit easier for others in the program too.\n\n## The Journey: From Simple Script to TUI Tool\n\nIt didn't start as anything fancy. My first attempt was just a small Python script to make the standard uVision templates we use work nicely with CLion, which is the IDE I prefer. But I quickly realized that just patching templates wasn't enough. I wanted to handle more tasks, and a single script was going to get messy fast.\n\nThat led me to think about a more organized approach. I started building a system where I could define different tasks or \"commands\" in separate files. The main program would automatically find these commands and show them in a simple console menu. This worked okay for a while, but managing the user interaction in the console got complicated as I added more features.\n\nThat's when I discovered **Textual**, a Python library for building TUIs. It was a game-changer! Suddenly, I didn't have to wrestle with printing menus, handling user input, or clearing the screen manually. Textual provided cool features like pop-up modals and even mouse support, letting me focus on the actual _logic_ of the commands.\n\nAdding new commands became much cleaner. For example, you can just create a new Python file (like `hello.py`) in the `interfaces` folder, write a function, and add a simple `@interface` decorator:\n\n```py\n# Example: interfaces/hello.py\nfrom textual.containers import Container\nfrom src.lib.interface import interface # My custom decorator\nfrom src.lib.utils import console\n\n@interface(\"My First Interface\") # This makes it show up in the TUI\nasync def hello_world(container: Container):\n    \"\"\"This is my first interface!\"\"\"\n    await console.print(container, \"Hello, World!\") # The actual command logic\n```\n\nThe main program picks this up automatically, making it really easy for anyone (even me later!) to add new automation tasks without digging through complex UI code.\n\n## Navigating Challenges: Hitting Python's Limits\n\nPretty soon, though, I ran into a couple of big hurdles that made me realize Python might not have been the _perfect_ choice for this specific tool, despite being great for getting started:\n\n1.  **Sharing the Tool Was a Pain:** Python scripts need a Python interpreter to run. To share TF Utils with classmates who might not have Python set up (or the right libraries), I had to bundle it into an `.exe` file for Windows. Using tools like AutoPyToExe felt like black magic, involving specific DLLs and complicated build scripts that often only worked reliably on my own laptop. This also basically locked the tool to Windows.\n2.  **Speed Over the Network:** The tool often needs to access project templates stored on our internal network drives. The Python version did this through the standard Windows file sharing, which could be noticeably slow, especially when copying lots of files.\n\nThinking about how to solve these issues led me to consider rewriting the tool in **Go (Golang)**. Go seemed like a good fit because:\n\n1.  It compiles directly into a single executable file for Windows, Mac, or Linux. No complex bundling needed, making distribution way easier and truly cross-platform.\n2.  Go is known for being fast, especially with network tasks. I could potentially use more direct methods like SFTP to talk to the server, hopefully speeding things up compared to going through Windows Explorer.\n\n## The Outcome: Where It Stands and What I Learned\n\nRight now, TF Utils (the Python version) is a working tool with a pretty nice TUI that does what I originally set out to do: automate common project setup tasks. It's documented, reasonably easy to add new commands to, and myself and a few friends in the program are actually using it regularly, which feels great! The build process is still clunky, but the tool itself is helpful.\n\nYou can check out the documentation here, which I put together using MkDocs with the Material theme: [https://imgajeed76.github.io/tfUtils/](https://imgajeed76.github.io/tfUtils/)\n\nSo, did I meet my goal? I think so. I wanted a structured way to simplify common tasks, and the current tool does that.\n\nAlong the way, I definitely learned a lot:\n\n- Got much better at using Python decorators for cool things like automatically discovering functions.\n- Figured out how to build decent TUIs with Textual.\n- Got a real-world lesson in the pros and cons of different programming languages – Python is awesome for quick development, but compiled languages like Go can be much better for distribution and performance in certain situations.\n\nI'm quite proud of how the TUI turned out and the modular system for adding commands. It feels pretty slick to use.\n\nAs mentioned, the next big idea is to actually build that V2 in Go. The plan is to tackle those distribution and speed problems head-on, making TF Utils even more useful and easier to share with everyone in the Electronics Technician program.",
    "repoUrl": "https://github.com/ImGajeed76/tfUtils",
    "createdAt": "2024-09-02T12:35:46Z",
    "updatedAt": "2025-04-21T20:18:00Z",
    "languages": [
      {
        "name": "Python",
        "bytes": 116290,
        "percentage": 92.66947700595271,
        "color": "#3572A5"
      },
      {
        "name": "Jinja",
        "bytes": 7094,
        "percentage": 5.653085130967654,
        "color": "#a52a22"
      },
      {
        "name": "Batchfile",
        "bytes": 1512,
        "percentage": 1.2048864840743012,
        "color": "#C1F12E"
      },
      {
        "name": "CMake",
        "bytes": 593,
        "percentage": 0.4725513790053312,
        "color": "#DA3434"
      }
    ],
    "primaryLanguage": {
      "name": "Python",
      "bytes": 116290,
      "percentage": 92.66947700595271,
      "color": "#3572A5"
    },
    "stars": 3,
    "forks": 1
  }
]